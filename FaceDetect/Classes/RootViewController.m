/*******************************************************************************
 * Copyright (c) 2011, Jean-David Gadina <macmade@eosgarden.com>
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
 
/* $Id$ */

/*!
 * @file        
 * @copyright   eosgarden 2011 - Jean-David Gadina <macmade@eosgarden.com>
 * @abstract    ...
 */

#import <opencv/cv.h>
#import "RootViewController.h"

@interface RootViewController( Private )

- ( UIImage * )scaleAndRotateImage: ( UIImage * )image;
- ( void )detectFace;
- ( void )openCvFaceDetect;
- ( IplImage * )createIplImage: ( UIImage * )image;

@end

@implementation RootViewController( Private )

- ( UIImage * )scaleAndRotateImage: ( UIImage * )image
{
    CGImageRef         imageRef;
    CGFloat            width;
    CGFloat            height;
    CGAffineTransform  transform;
    CGRect             bounds;
    CGFloat            ratio;
    CGFloat            scaleRatio;
    CGSize             imageSize;
    CGFloat            boundHeight;
    UIImageOrientation orientation;
    CGContextRef       context;
    UIImage          * newImage;
    
    imageRef  = image.CGImage;
    width     = CGImageGetWidth( imageRef );
    height    = CGImageGetHeight( imageRef );
    bounds    = CGRectMake( 0, 0, width, height );
    
    if( width > DETECT_IMAGE_MAX_SIZE || height > DETECT_IMAGE_MAX_SIZE )
    {
        ratio = width / height;
        
        if( ratio > 1 )
        {
            bounds.size.width  = DETECT_IMAGE_MAX_SIZE;
            bounds.size.height = bounds.size.width / ratio;
        }
        else
        {
            bounds.size.width  = bounds.size.height * ratio;
            bounds.size.height = DETECT_IMAGE_MAX_SIZE;
        }
    }
    
    scaleRatio  = bounds.size.width / width;
    imageSize   = CGSizeMake( width, height );
    orientation = image.imageOrientation;
    
    switch( orientation )
    {
        case UIImageOrientationUp:
            
            transform = CGAffineTransformIdentity;
            
            break;
            
        case UIImageOrientationDown:
            
            transform = CGAffineTransformMakeTranslation( imageSize.width, imageSize.height );
            transform = CGAffineTransformRotate( transform, ( CGFloat )M_PI );
            
            break;
            
        case UIImageOrientationLeft:
            
            boundHeight        = bounds.size.height;
            bounds.size.height = bounds.size.width;
            bounds.size.width  = boundHeight;
            transform          = CGAffineTransformMakeTranslation( ( CGFloat )0, imageSize.width );
            transform          = CGAffineTransformRotate( transform, ( CGFloat )( 3 * M_PI / 2 ) );
            
            break;
            
        case UIImageOrientationRight:
            
            boundHeight        = bounds.size.height;
            bounds.size.height = bounds.size.width;
            bounds.size.width  = boundHeight;
            transform          = CGAffineTransformMakeTranslation( imageSize.height, ( CGFloat )0 );
            transform          = CGAffineTransformRotate( transform, ( CGFloat )( M_PI / 2 ) );
            
            break;
            
        case UIImageOrientationUpMirrored:
            
            transform = CGAffineTransformMakeTranslation( imageSize.width, ( CGFloat )0 );
            transform = CGAffineTransformScale(transform, ( CGFloat )-1, ( CGFloat )1 );
            
            break;
            
        case UIImageOrientationDownMirrored:
            
            transform = CGAffineTransformMakeTranslation( ( CGFloat )0, imageSize.height );
            transform = CGAffineTransformScale( transform, ( CGFloat )1, ( CGFloat )-1 );
            
            break;
            
        case UIImageOrientationLeftMirrored:
            
            boundHeight        = bounds.size.height;
            bounds.size.height = bounds.size.width;
            bounds.size.width  = boundHeight;
            transform          = CGAffineTransformMakeTranslation( imageSize.height, imageSize.width );
            transform          = CGAffineTransformScale( transform, ( CGFloat )-1, ( CGFloat )1 );
            transform          = CGAffineTransformRotate( transform, ( CGFloat )( 3 * M_PI / 2 ) );
            
            break;
            
        case UIImageOrientationRightMirrored:
            
            boundHeight        = bounds.size.height;
            bounds.size.height = bounds.size.width;
            bounds.size.width  = boundHeight;
            transform          = CGAffineTransformMakeScale( ( CGFloat )-1, ( CGFloat )1 );
            transform          = CGAffineTransformRotate( transform, ( CGFloat )( M_PI / 2 ) );
            
            break;
            
        default:
            
            transform = CGAffineTransformIdentity;
            
            break;
    }
    
    UIGraphicsBeginImageContext( bounds.size );
    
    context = UIGraphicsGetCurrentContext();
    
    if( orientation == UIImageOrientationRight || orientation == UIImageOrientationLeft )
    {
        CGContextScaleCTM( context, -scaleRatio, scaleRatio );
        CGContextTranslateCTM( context, -height, 0 );
    }
    else
    {
        CGContextScaleCTM( context, scaleRatio, -scaleRatio );
        CGContextTranslateCTM( context, 0, -height );
    }
    
    CGContextConcatCTM( context, transform );
    CGContextDrawImage( UIGraphicsGetCurrentContext(), CGRectMake( 0, 0, width, height ), imageRef );
    
    newImage = UIGraphicsGetImageFromCurrentImageContext();
    
    UIGraphicsEndImageContext();
    
    return newImage;
}

- ( void )detectFace
{
    detecting      = YES;
    progress       = [ [ UIActivityIndicatorView alloc ] initWithActivityIndicatorStyle: UIActivityIndicatorViewStyleWhiteLarge ];
    progress.frame = CGRectMake
    (
        ( self.view.frame.size.width / 2 ) - ( progress.frame.size.width / 2 ),
        ( self.view.frame.size.height / 2 ) - ( progress.frame.size.height / 2 ),
        progress.frame.size.width,
        progress.frame.size.height
    );
    
    [ progress startAnimating ];
    
    [ self.view addSubview: progress ];
    [ self performSelectorInBackground: @selector( openCvFaceDetect ) withObject: nil ];
}

- ( void )openCvFaceDetect
{
    NSInteger                 i;
    NSUInteger                scale;
    NSAutoreleasePool       * pool;
    IplImage                * image;
    IplImage                * smallImage;
    NSString                * xmlPath;
    CvHaarClassifierCascade * cascade;
    CvMemStorage            * storage;
    CvSeq                   * faces;
    UIAlertView             * alert;
    CGImageRef                imageRef;
    CGColorSpaceRef           colorSpaceRef;
    CGContextRef              context;
    CvRect                    rect;
    CGRect                    faceRect;
    
    pool  = [ [ NSAutoreleasePool alloc ] init ];
    scale = 2;
    
    cvSetErrMode( CV_ErrModeParent );
    
    xmlPath    = [ [ NSBundle mainBundle ] pathForResource: @"haarcascade_frontalface_default" ofType: @"xml" ];
    image      = [ self createIplImage: imageView.image ];
    smallImage = cvCreateImage( cvSize( image->width / scale, image->height / scale ), IPL_DEPTH_8U, 3 );
    
    cvPyrDown( image, smallImage, CV_GAUSSIAN_5x5 );
    
    cascade = ( CvHaarClassifierCascade * )cvLoad( [ xmlPath cStringUsingEncoding: NSASCIIStringEncoding ], NULL, NULL, NULL );
    storage = cvCreateMemStorage( 0 );
    faces   = cvHaarDetectObjects( smallImage, cascade, storage, ( float )1.2, 2, CV_HAAR_DO_CANNY_PRUNING, cvSize( 20, 20 ) );
    
    cvReleaseImage( &smallImage );
    
    imageRef      = imageView.image.CGImage;
    colorSpaceRef = CGColorSpaceCreateDeviceRGB();
    context       = CGBitmapContextCreate
    (
        NULL,
        imageView.image.size.width,
        imageView.image.size.height,
        8,
        imageView.image.size.width * 4,
        colorSpaceRef,
        kCGImageAlphaPremultipliedLast | kCGBitmapByteOrderDefault
    );
    
    CGContextDrawImage
    (
        context,
        CGRectMake( 0, 0, imageView.image.size.width, imageView.image.size.height ),
        imageRef
    );
    
    CGContextSetLineWidth( context, 1 );
    CGContextSetRGBStrokeColor( context, ( CGFloat )0, ( CGFloat )0, ( CGFloat )0, ( CGFloat )0.5 );
    CGContextSetRGBFillColor( context, ( CGFloat )1, ( CGFloat )1, ( CGFloat )1, ( CGFloat )0.5 );
    
    if( faces->total == 0 )
    {
        alert = [ [ UIAlertView alloc ] initWithTitle: @"No faces" message: @"No faces were detected in the picture. Please try with another one." delegate: NULL cancelButtonTitle: @"OK" otherButtonTitles: nil ];
        
        [ alert show ];
        [ alert release ];
    }
    else
    {
        for( i = 0; i < faces->total; i++ )
        {
            rect     = *( CvRect * )cvGetSeqElem( faces, i );
            faceRect = CGContextConvertRectToDeviceSpace( context, CGRectMake( rect.x * scale, rect.y * scale, rect.width * scale, rect.height * scale ) );
            
            CGContextFillRect( context, faceRect );
            CGContextStrokeRect( context, faceRect );
        }
        
        imageView.image = [ UIImage imageWithCGImage: CGBitmapContextCreateImage( context ) ];
    }
    
    CGContextRelease( context );
    CGColorSpaceRelease( colorSpaceRef );
    cvReleaseMemStorage( &storage );
    cvReleaseHaarClassifierCascade( &cascade );
    cvReleaseImage( &smallImage );
    
    [ progress removeFromSuperview ];
    [ progress release ];
    
    progress  = nil;
    detecting = NO;
    
    [pool release];
}

- ( IplImage * )createIplImage: ( UIImage * )image
{
    CGImageRef      imageRef;
    CGColorSpaceRef colorSpaceRef;
    CGContextRef    context;
    IplImage      * iplImage;
    IplImage      * returnImage;
    
    imageRef      = image.CGImage;
    colorSpaceRef = CGColorSpaceCreateDeviceRGB();
    iplImage      = cvCreateImage( cvSize( image.size.width, image.size.height ), IPL_DEPTH_8U, 4 );
    context       = CGBitmapContextCreate
    (
        iplImage->imageData,
        iplImage->width,
        iplImage->height,
        iplImage->depth,
        iplImage->widthStep,
        colorSpaceRef,
        kCGImageAlphaPremultipliedLast | kCGBitmapByteOrderDefault
    );
    
    CGContextDrawImage( context, CGRectMake( 0, 0, image.size.width, image.size.height ), imageRef );
    CGContextRelease( context );
    CGColorSpaceRelease( colorSpaceRef );
    
    returnImage = cvCreateImage( cvGetSize( iplImage ), IPL_DEPTH_8U, 3 );
    
    cvCvtColor( iplImage, returnImage, CV_RGBA2BGR );
    cvReleaseImage( &iplImage );
    
    return returnImage;
}

@end

@implementation RootViewController

@synthesize imageView;

- ( id )initWithCoder: ( NSCoder * )coder
{
    if( ( self = [ super initWithCoder: coder ] ) )
    {
        picker          = [ [ UIImagePickerController alloc ] init ];
        picker.delegate = self;
        firstRun        = YES;
    }
    
    return self;
}

- ( void )dealloc
{
    [ imageView release ];
    [ super dealloc ];
}

- (void)didReceiveMemoryWarning
{
    [super didReceiveMemoryWarning];
}

- ( BOOL )shouldAutorotateToInterfaceOrientation: ( UIInterfaceOrientation )interfaceOrientation
{
    return ( interfaceOrientation == UIInterfaceOrientationPortrait );
}

- ( void )loadView
{
    [ super loadView ];
}

- ( void )viewDidLoad
{
    [ super viewDidLoad ];
}

- ( void )viewDidAppear: ( BOOL )animated
{
    [ super viewDidAppear: animated ];
    
    if( firstRun == YES )
    {
        firstRun = NO;
        
        [ self takePicture: nil ];
    }
}

- ( void )viewDidUnload
{
    [ super viewDidUnload ];
}

- ( IBAction )takePicture: ( id )sender
{
    UIActionSheet * sheet;
    
    if( detecting == YES || picker == nil )
    {
        return;
    }
    
    sheet = [ [ UIActionSheet alloc ] initWithTitle: @"Take a picture from:" delegate: self cancelButtonTitle: @"Cancel" destructiveButtonTitle: nil otherButtonTitles: @"Camera", @"Picture library", @"Saved photo album", nil ];
    
    [ sheet showInView: self.view ];
}

- ( void )actionSheet: ( UIActionSheet * )actionSheet clickedButtonAtIndex: ( NSInteger )buttonIndex
{
    UIAlertView * alert;
    
    @try {
        
        switch( buttonIndex )
        {
            case 0:
                
                picker.sourceType = UIImagePickerControllerSourceTypeCamera;
                break;
                
            case 1:
                
                picker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;
                break;
                
            case 2:
                
                picker.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum;
                break;
                
            default:
                
                [ actionSheet release ];
                
                return;
        }
    }
    @catch( NSException * exception )
    {
        alert = [ [ UIAlertView alloc ] initWithTitle: @"Error" message: @"The choosed source is not available. Please select another one." delegate: nil cancelButtonTitle: @"OK" otherButtonTitles: nil ];
        
        [ alert show ];
        [ alert release ];
        [ actionSheet release ];
        
        return;
    }
    
    [ self presentModalViewController: picker animated: YES ];
    [ actionSheet release ];
}

- ( void )imagePickerController: ( UIImagePickerController * )pickerObject didFinishPickingImage: ( UIImage * )image editingInfo: ( NSDictionary * )editingInfo
{
    ( void )pickerObject;
    ( void )editingInfo;
    
    [ self dismissModalViewControllerAnimated: YES ];
    
    imageView.image = [ self scaleAndRotateImage: image ];
    
    [ self detectFace ];
}

- ( void )imagePickerControllerDidCancel: ( UIImagePickerController * )pickerObject
{
    [ self dismissModalViewControllerAnimated: YES ];
}

@end
